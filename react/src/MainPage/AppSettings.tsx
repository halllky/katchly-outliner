import React, { useCallback, useEffect, useMemo, useRef } from 'react'
import * as Util from '../__autoGenerated/util'
import * as Input from '../__autoGenerated/input'
import { ColumnDefEx, DataTable, VerticalForm, ModalDialog, DataTableRef, DataTableProps } from '../__autoGenerated/collection'
import { RadioGroupBase } from '../__autoGenerated/input/ToggleBase'
import { ColumnId, EditableObject, RowType, RowTypeColumn, createNewRowType } from './Types'
import { useFieldArray } from 'react-hook-form'
import { useKatchlyRepository } from './MainPageRepos'
import { UUID } from 'uuidjs'
import { MinusIcon, PlusIcon } from '@heroicons/react/24/outline'
import { RowStateBar } from './RowStateBar'

export type AppSetting = {
  windowTitle?: string
  userName?: string
  detailViewPosition?: 'right' | 'bottom' | ''
}

export const [AppSettingContext, useAppSettings] = Util.defineStorageContext({
  storageKey: 'OUTLINER::APPSETTINGS',
  defaultValue: (): AppSetting => ({
    userName: '',
    detailViewPosition: 'right',
  }),
  deserialize: str => ({ ok: true, obj: JSON.parse(str) as AppSetting }),
  serialize: obj => JSON.stringify(obj),
})

/** 設定画面 */
export const AppSttingsDialog = ({ open, onClose }: {
  open: boolean
  onClose: () => void
}) => {
  const [, dispatchToast] = Util.useToastContext()
  const { post } = Util.useHttpRequest()

  // 行型定義
  const {
    dataTableProps,
    appendNewColumn,
    appendNewRowType,
    removeColumn,
    removeRowType,
    saveRowTypes,
  } = useRowTypeEditor()

  // アプリ設定
  const { data, save } = useAppSettings()
  const { reset, registerEx, getValues } = Util.useFormEx<typeof data>({})
  useEffect(() => {
    reset(data)
  }, [data])

  // 保存
  const onSave = useCallback(async () => {
    save(getValues())
    await saveRowTypes()
    dispatchToast(msg => msg.info('設定を保存しました。'))
    onClose()
  }, [save, dispatchToast, onClose, getValues, saveRowTypes])

  // データ操作
  const recreateDatabase = useCallback(async () => {
    if (window.confirm('DBを再作成します。データは全て削除されます。よろしいですか？')
      && window.confirm('後悔しませんね？')) {
      const response = await post('/WebDebugger/recreate-database')
      if (response.ok) {
        dispatchToast(msg => msg.info('DBを再作成しました。'))
      } else {
        dispatchToast(msg => msg.error('DBの再作成に失敗しました。'))
      }
    }
  }, [post, dispatchToast])

  // キーハンドリング
  const onKeyDown: React.KeyboardEventHandler = useCallback(e => {
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      onSave()
      e.preventDefault()
    }
  }, [onSave])

  return (
    <ModalDialog title="設定" open={open} onClose={onClose} onKeyDown={onKeyDown}>
      <div className="h-full flex flex-col gap-1">
        <div className="flex-1 flex flex-col gap-4 p-px overflow-auto">
          <VerticalForm.Container
            label={(
              <div className="flex gap-1 items-center p-px w-full">
                <VerticalForm.LabelText>行タイプ設定</VerticalForm.LabelText>
                <Input.IconButton icon={PlusIcon} onClick={appendNewRowType} outline>タイプ追加</Input.IconButton>
                <Input.IconButton icon={MinusIcon} onClick={removeRowType} outline>タイプ削除</Input.IconButton>
                <div className="basis-4"></div>
                <Input.IconButton icon={PlusIcon} onClick={appendNewColumn} outline>列追加</Input.IconButton>
                <Input.IconButton icon={MinusIcon} onClick={removeColumn} outline>列削除</Input.IconButton>
              </div>
            )}
          >
            <VerticalForm.Item wide>
              <DataTable
                {...dataTableProps}
                className="h-64"
              />
            </VerticalForm.Item>
          </VerticalForm.Container>

          <VerticalForm.Container label="アプリ設定" estimatedLabelWidth="14rem">
            <VerticalForm.Item label="ウィンドウ表示名">
              <Input.Word {...registerEx(`windowTitle`)} />
            </VerticalForm.Item>
            <VerticalForm.Item label="ユーザー名">
              <Input.Word {...registerEx(`userName`)} />
            </VerticalForm.Item>
            <VerticalForm.Item
              label={(
                <div className="flex flex-col">
                  <VerticalForm.LabelText>詳細表示パネルの位置</VerticalForm.LabelText>
                  <span className="text-xs select-none text-color-6">(Ctrl + B でも変更可能)</span>
                </div>
              )}
            >
              <RadioGroupBase
                {...registerEx(`detailViewPosition`)}
                options={DETAIL_VIEW_POSITION}
                keySelector={KEY_SELECTOR}
                textSelector={TEXT_SELECTOR}
              />
            </VerticalForm.Item>
          </VerticalForm.Container>

          <VerticalForm.Container label="データ操作">
            <VerticalForm.Item wide>
              <Input.IconButton outline onClick={recreateDatabase}>DB再作成</Input.IconButton>
            </VerticalForm.Item>
          </VerticalForm.Container>
        </div>

        <footer className="pt-1 border-t border-color-3 flex justify-end">
          <Input.IconButton fill onClick={onSave}>保存</Input.IconButton>
        </footer>
      </div>
    </ModalDialog>
  )
}

// 詳細表示パネルの位置
type DetailViewOption = { key: 'right' | 'bottom' | '', text: string }
const DETAIL_VIEW_POSITION: DetailViewOption[] = [
  { key: 'right' as const, text: '右' },
  { key: 'bottom' as const, text: '下' },
]
const KEY_SELECTOR = (x: DetailViewOption) => x.key
const TEXT_SELECTOR = (x: DetailViewOption) => x.text

// ----------------------------------------
// 行型定義の編集
type RowTypeEditorFormValue = { items: RowTypeEditorItem[] }
type RowTypeEditorItem
  = { type: 'rowTypeDef', item: RowType }
  | (EditableObject & { type: 'columnDef', item: RowTypeColumn })

const useRowTypeEditor = () => {
  const { loadAll, saveAll } = useKatchlyRepository()
  const { control, reset, getValues } = Util.useFormEx<RowTypeEditorFormValue>({})
  const { fields, append, insert, update, remove } = useFieldArray({ control, name: 'items' })
  const gridRef = useRef<DataTableRef<RowTypeEditorItem>>(null)

  useEffect(() => {
    loadAll().then(({ rowTypes }) => {
      const editorValue = convertToEditorTable(rowTypes)
      reset(editorValue)
    })
  }, [loadAll])

  const saveRowTypes = useCallback(async () => {
    const rowTypes = convertToSaveType(getValues())
    await saveAll({ rowTypes })
    const { rowTypes: afterSave } = await loadAll()
    reset(convertToEditorTable(afterSave))
  }, [saveAll, loadAll, reset, getValues])

  const rowTypeEditorColumnDef = useMemo((): ColumnDefEx<RowTypeEditorItem>[] => [{
    id: 'col0',
    header: '　',
    accessorFn: row => row.item.name,
    cell: cellProps => (
      <div className="flex">
        <RowStateBar state={Util.getLocalRepositoryState(cellProps.row.original.type === 'rowTypeDef'
          ? cellProps.row.original.item
          : cellProps.row.original)} />
        <span className={`flex-1 block overflow-hidden whitespace-nowrap ${cellProps.row.original.type === 'columnDef' ? 'px-8' : ''}`}>
          {cellProps.row.original.item.name}&nbsp;
        </span>
      </div>
    ),
    editSetting: {
      type: 'text',
      getTextValue: row => row.item.name,
      setTextValue: (row, value) => {
        row.item.name = value
      },
    },
  }], [])

  const appendNewRowType = useCallback(() => {
    append({ type: 'rowTypeDef', item: createNewRowType() })
  }, [append])

  const removeRowType = useCallback(() => {
    const selected = gridRef.current?.getSelectedRows()[0]
    if (!selected) return
    let start = selected.rowIndex
    while (fields[start].type !== 'rowTypeDef') {
      start--
    }
    let end = start + 1
    while (fields[end]?.type === 'columnDef') {
      end++
    }
    const removedIndex: number[] = []
    for (let i = start; i < end; i++) {
      const row = fields[i]
      if (row.type === 'rowTypeDef') {
        if (row.item.existsInRemoteRepository) {
          update(i, { ...row, item: { ...row.item, willBeDeleted: true } })
        } else {
          removedIndex.push(i)
        }
      } else {
        if (row.existsInRemoteRepository) {
          update(i, { ...row, willBeDeleted: true })
        } else {
          removedIndex.push(i)
        }
      }
    }
    if (removedIndex.length > 0) {
      remove(...removedIndex)
    }
  }, [gridRef, fields, update, remove])

  const appendNewColumn = useCallback(() => {
    const selected = gridRef.current?.getSelectedRows()[0]
    if (!selected) return
    let start = selected.rowIndex
    while (fields[start].type !== 'rowTypeDef') {
      start--
    }
    let end = start + 1
    while (fields[end]?.type === 'columnDef') {
      end++
    }
    const rowTypeRow = fields[start]
    if (rowTypeRow.type !== 'rowTypeDef') return
    insert(end, {
      type: 'columnDef',
      item: { id: `["${rowTypeRow.item.id}", "${UUID.generate()}"]` as ColumnId, valueIs: 'Text', comments: [] },
      existsInRemoteRepository: false,
      willBeChanged: true,
      willBeDeleted: false,
    })
  }, [fields, gridRef, insert])

  const removeColumn = useCallback(() => {
    const selected = gridRef.current?.getSelectedRows()[0]
    if (!selected) return
    if (selected.row.type !== 'columnDef') return
    if (selected.row.existsInRemoteRepository) {
      update(selected.rowIndex, { ...selected.row, willBeDeleted: true })
    } else {
      remove(selected.rowIndex)
    }
  }, [gridRef, update, remove])

  const dataTableProps: DataTableProps<RowTypeEditorItem> = {
    data: fields,
    columns: rowTypeEditorColumnDef,
    onChangeRow: update,
  }
  return {
    dataTableProps: { ref: gridRef, ...dataTableProps },
    appendNewRowType,
    appendNewColumn,
    removeRowType,
    removeColumn,
    saveRowTypes,
  }
}

const convertToEditorTable = (rowTypes: RowType[]): RowTypeEditorFormValue => {
  const items = Array.from(rowTypes).flatMap<RowTypeEditorItem>(rowType => [
    {
      type: 'rowTypeDef',
      item: rowType,
      existsInRemoteRepository: true,
      willBeChanged: false,
      willBeDeleted: false,
    },
    ...rowType.columns.map<RowTypeEditorItem>(col => ({
      type: 'columnDef',
      item: col,
      existsInRemoteRepository: true,
      willBeChanged: false,
      willBeDeleted: false,
    })),
  ])
  return { items }
}
const convertToSaveType = ({ items }: RowTypeEditorFormValue): RowType[] => {
  if (items.length === 0) return []
  const result: RowType[] = []
  let rowType = items[0].item as RowType
  let columns: RowTypeColumn[] = []
  let i = 0
  while (i < items.length) {
    const row = items[i]
    if (row.type === 'rowTypeDef') {
      rowType = row.item
    } else {
      const state = Util.getLocalRepositoryState(row)
      if (state !== '') rowType.willBeChanged = true
      if (!row.willBeDeleted) columns.push(row.item)
    }
    i++
    if (items[i]?.type !== 'columnDef') {
      result.push({ ...rowType, columns })
      columns = []
    }
  }
  return result
}
