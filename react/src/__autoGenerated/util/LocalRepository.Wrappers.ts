import { useState, useMemo, useCallback, useEffect } from 'react'
import { UUID } from 'uuidjs'
import { useMsgContext } from './Notification'
import { useHttpRequest } from './Http'
import {
  ItemKey,
  useLocalRepositoryContext,
  useIndexedDbLocalRepositoryTable,
} from './LocalRepository'
import { crossJoin } from './JsUtil'
import * as AggregateType from '../autogenerated-types'

/** 参照先データの読み込みと保存を行います。 */
export const use参照先Repository = (editRange?
  // データ新規作成の場合
  : ItemKey
  // 複数件編集の場合
  | { filter: AggregateType.参照先SearchCondition, skip?: number, take?: number }
  // 1件編集の場合
  | [参照先ID: string | undefined]
) => {

  const [, dispatchMsg] = useMsgContext()
  const { get, post } = useHttpRequest()
  const { reload: reloadContext } = useLocalRepositoryContext()
  const { ready: ready2, openCursor, queryToTable } = useIndexedDbLocalRepositoryTable()

  const load = useCallback(async (): Promise<AggregateType.参照先DisplayData[] | undefined> => {
    if (!ready2) return
    if (editRange === undefined) return // 画面表示直後の検索条件が決まっていない場合など


    let remoteItems: AggregateType.参照先DisplayData[]
    let localItems: AggregateType.参照先DisplayData[]

    if (typeof editRange === 'string') {
      // 新規作成データの検索。
      // まだリモートに存在しないためローカルにのみ検索をかける
      remoteItems = []
      const found = await queryToTable(table => table.get(['参照先', editRange]))
      localItems = found ? [found.item as AggregateType.参照先DisplayData] : []

    } else if (Array.isArray(editRange)) {
      // 既存データのキーによる検索（リモートリポジトリ）
      if (editRange[0] === undefined) {
        remoteItems = []
      } else {
        const res = await get(`/api/参照先/detail/${window.encodeURI(editRange[0].toString())}`)
        remoteItems = res.ok
          ? [res.data as AggregateType.参照先DisplayData]
          : []
      }

      // 既存データのキーによる検索（ローカルリポジトリ）
      const itemKey = JSON.stringify(editRange)
      const found = await queryToTable(table => table.get(['参照先', itemKey]))
      localItems = found ? [found.item as AggregateType.参照先DisplayData] : []

    } else {
      // 既存データの検索条件による検索（リモートリポジトリ）
      const searchParam = new URLSearchParams()
      if (editRange.skip !== undefined) searchParam.append('skip', editRange.skip.toString())
      if (editRange.take !== undefined) searchParam.append('take', editRange.take.toString())
      const url = `/api/参照先/load?${searchParam}`
      const res = await post<AggregateType.参照先DisplayData[]>(url, editRange.filter)
      remoteItems = res.ok ? res.data : []

      // 既存データの検索条件による検索（ローカルリポジトリ）
      localItems = []
      await openCursor('readonly', cursor => {
        if (cursor.value.dataTypeKey !== '参照先') return
        // TODO: ローカルリポジトリのデータは参照先のキーと名前しか持っていないのでfilterでそれらが検索条件に含まれていると正確な範囲がとれない
        // const item = cursor.value.item as AggregateType.参照先DisplayData
        // if (editRange.filter.参照先ID !== undefined
        //   && item.参照先ID !== editRange.filter.参照先ID) return
        // if (editRange.filter.Name !== undefined
        //   && item.Name !== editRange.filter.Name) return
        localItems.push(cursor.value.item as AggregateType.参照先DisplayData)
      })
    }

    // ローカルリポジトリにあるデータはそちらを優先的に表示する
    const remoteAndLocal =  crossJoin(
      localItems, local => local.localRepositoryItemKey,
      remoteItems, remote => remote.localRepositoryItemKey,
    ).map<AggregateType.参照先DisplayData>(pair => pair.left ?? pair.right)

    return remoteAndLocal

  }, [editRange, get, post, queryToTable, openCursor])

  /** 引数に渡されたデータをローカルリポジトリに登録します。 */
  const commit = useCallback(async (...items: AggregateType.参照先DisplayData[]) => {
    for (const newValue of items) {
      if (newValue.willBeDeleted && !newValue.existsInRemoteRepository) {
        await queryToTable(table => table.delete(['参照先', newValue.localRepositoryItemKey]))

      } else if (newValue.willBeChanged || newValue.willBeDeleted) {
        await queryToTable(table => table.put({
          dataTypeKey: '参照先',
          itemKey: newValue.localRepositoryItemKey,
          itemName: `${newValue.own_members?.Name}`,
          item: newValue,
          existsInRemoteRepository: newValue.existsInRemoteRepository,
          willBeChanged: newValue.willBeChanged,
          willBeDeleted: newValue.willBeDeleted,
        }))
      }
    }

    await reloadContext() // 更新があったことをサイドメニューに知らせる
  }, [reloadContext, queryToTable])

  return {
    ready: ready2,
    load,
    commit,
  }
}
/** 親集約データの読み込みと保存を行います。 */
export const use親集約Repository = (editRange?
  // データ新規作成の場合
  : ItemKey
  // 複数件編集の場合
  | { filter: AggregateType.親集約SearchCondition, skip?: number, take?: number }
  // 1件編集の場合
  | [ID: string | undefined]
) => {

  const [, dispatchMsg] = useMsgContext()
  const { get, post } = useHttpRequest()
  const { reload: reloadContext } = useLocalRepositoryContext()
  const { ready: ready2, openCursor, queryToTable } = useIndexedDbLocalRepositoryTable()

  const load = useCallback(async (): Promise<AggregateType.親集約DisplayData[] | undefined> => {
    if (!ready2) return
    if (editRange === undefined) return // 画面表示直後の検索条件が決まっていない場合など


    let remoteItems: AggregateType.親集約DisplayData[]
    let localItems: AggregateType.親集約DisplayData[]

    if (typeof editRange === 'string') {
      // 新規作成データの検索。
      // まだリモートに存在しないためローカルにのみ検索をかける
      remoteItems = []
      const found = await queryToTable(table => table.get(['親集約', editRange]))
      localItems = found ? [found.item as AggregateType.親集約DisplayData] : []

    } else if (Array.isArray(editRange)) {
      // 既存データのキーによる検索（リモートリポジトリ）
      if (editRange[0] === undefined) {
        remoteItems = []
      } else {
        const res = await get(`/api/親集約/detail/${window.encodeURI(editRange[0].toString())}`)
        remoteItems = res.ok
          ? [res.data as AggregateType.親集約DisplayData]
          : []
      }

      // 既存データのキーによる検索（ローカルリポジトリ）
      const itemKey = JSON.stringify(editRange)
      const found = await queryToTable(table => table.get(['親集約', itemKey]))
      localItems = found ? [found.item as AggregateType.親集約DisplayData] : []

    } else {
      // 既存データの検索条件による検索（リモートリポジトリ）
      const searchParam = new URLSearchParams()
      if (editRange.skip !== undefined) searchParam.append('skip', editRange.skip.toString())
      if (editRange.take !== undefined) searchParam.append('take', editRange.take.toString())
      const url = `/api/親集約/load?${searchParam}`
      const res = await post<AggregateType.親集約DisplayData[]>(url, editRange.filter)
      remoteItems = res.ok ? res.data : []

      // 既存データの検索条件による検索（ローカルリポジトリ）
      localItems = []
      await openCursor('readonly', cursor => {
        if (cursor.value.dataTypeKey !== '親集約') return
        // TODO: ローカルリポジトリのデータは参照先のキーと名前しか持っていないのでfilterでそれらが検索条件に含まれていると正確な範囲がとれない
        // const item = cursor.value.item as AggregateType.親集約DisplayData
        // if (editRange.filter.ID !== undefined
        //   && item.ID !== editRange.filter.ID) return
        // if (editRange.filter.単語 !== undefined
        //   && item.単語 !== editRange.filter.単語) return
        // if (editRange.filter.文章 !== undefined
        //   && item.文章 !== editRange.filter.文章) return
        //
        //
        //
        //
        //
        //
        // if (editRange.filter.参照?.参照先ID !== undefined
        //   && item.参照?.参照先ID !== editRange.filter.参照.参照先ID) return
        // if (editRange.filter.参照?.Name !== undefined
        //   && item.参照?.Name !== editRange.filter.参照.Name) return
        // if (editRange.filter.真偽値 !== undefined
        //   && item.真偽値 !== editRange.filter.真偽値) return
        // if (editRange.filter.列挙体 !== undefined
        //   && item.列挙体 !== editRange.filter.列挙体) return
        localItems.push(cursor.value.item as AggregateType.親集約DisplayData)
      })
    }

    // ローカルリポジトリにあるデータはそちらを優先的に表示する
    const remoteAndLocal =  crossJoin(
      localItems, local => local.localRepositoryItemKey,
      remoteItems, remote => remote.localRepositoryItemKey,
    ).map<AggregateType.親集約DisplayData>(pair => pair.left ?? pair.right)

    return remoteAndLocal

  }, [editRange, get, post, queryToTable, openCursor])

  /** 引数に渡されたデータをローカルリポジトリに登録します。 */
  const commit = useCallback(async (...items: AggregateType.親集約DisplayData[]) => {
    for (const newValue of items) {
      if (newValue.willBeDeleted && !newValue.existsInRemoteRepository) {
        await queryToTable(table => table.delete(['親集約', newValue.localRepositoryItemKey]))

      } else if (newValue.willBeChanged || newValue.willBeDeleted) {
        await queryToTable(table => table.put({
          dataTypeKey: '親集約',
          itemKey: newValue.localRepositoryItemKey,
          itemName: `${newValue.own_members?.文章}`,
          item: newValue,
          existsInRemoteRepository: newValue.existsInRemoteRepository,
          willBeChanged: newValue.willBeChanged,
          willBeDeleted: newValue.willBeDeleted,
        }))
      }
    }

    await reloadContext() // 更新があったことをサイドメニューに知らせる
  }, [reloadContext, queryToTable])

  return {
    ready: ready2,
    load,
    commit,
  }
}
