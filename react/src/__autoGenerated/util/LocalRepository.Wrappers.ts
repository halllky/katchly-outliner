import { useState, useMemo, useCallback, useEffect } from 'react'
import { UUID } from 'uuidjs'
import { useMsgContext } from './Notification'
import { useHttpRequest } from './Http'
import {
  ItemKey,
  useLocalRepositoryContext,
  useIndexedDbLocalRepositoryTable,
} from './LocalRepository'
import { crossJoin } from './JsUtil'
import * as AggregateType from '../autogenerated-types'

/** RowTypeデータの読み込みと保存を行います。 */
export const useRowTypeRepository = (editRange?
  // データ新規作成の場合
  : ItemKey
  // 複数件編集の場合
  | { filter: AggregateType.RowTypeSearchCondition, skip?: number, take?: number }
  // 1件編集の場合
  | [ID: string | undefined]
) => {

  const [, dispatchMsg] = useMsgContext()
  const { get, post } = useHttpRequest()
  const { reload: reloadContext } = useLocalRepositoryContext()
  const { ready: ready2, openCursor, queryToTable } = useIndexedDbLocalRepositoryTable()

  const load = useCallback(async (): Promise<AggregateType.RowTypeDisplayData[] | undefined> => {
    if (!ready2) return
    if (editRange === undefined) return // 画面表示直後の検索条件が決まっていない場合など


    let remoteItems: AggregateType.RowTypeDisplayData[]
    let localItems: AggregateType.RowTypeDisplayData[]

    if (typeof editRange === 'string') {
      // 新規作成データの検索。
      // まだリモートに存在しないためローカルにのみ検索をかける
      remoteItems = []
      const found = await queryToTable(table => table.get(['RowType', editRange]))
      localItems = found ? [found.item as AggregateType.RowTypeDisplayData] : []

    } else if (Array.isArray(editRange)) {
      // 既存データのキーによる検索（リモートリポジトリ）
      if (editRange[0] === undefined) {
        remoteItems = []
      } else {
        const res = await get(`/api/RowType/detail/${window.encodeURI(editRange[0].toString())}`)
        remoteItems = res.ok
          ? [res.data as AggregateType.RowTypeDisplayData]
          : []
      }

      // 既存データのキーによる検索（ローカルリポジトリ）
      const itemKey = JSON.stringify(editRange)
      const found = await queryToTable(table => table.get(['RowType', itemKey]))
      localItems = found ? [found.item as AggregateType.RowTypeDisplayData] : []

    } else {
      // 既存データの検索条件による検索（リモートリポジトリ）
      const searchParam = new URLSearchParams()
      if (editRange.skip !== undefined) searchParam.append('skip', editRange.skip.toString())
      if (editRange.take !== undefined) searchParam.append('take', editRange.take.toString())
      const url = `/api/RowType/load?${searchParam}`
      const res = await post<AggregateType.RowTypeDisplayData[]>(url, editRange.filter)
      remoteItems = res.ok ? res.data : []

      // 既存データの検索条件による検索（ローカルリポジトリ）
      localItems = []
      await openCursor('readonly', cursor => {
        if (cursor.value.dataTypeKey !== 'RowType') return
        // TODO: ローカルリポジトリのデータは参照先のキーと名前しか持っていないのでfilterでそれらが検索条件に含まれていると正確な範囲がとれない
        // const item = cursor.value.item as AggregateType.RowTypeDisplayData
        // if (editRange.filter.ID !== undefined
        //   && item.ID !== editRange.filter.ID) return
        localItems.push(cursor.value.item as AggregateType.RowTypeDisplayData)
      })
    }

    // ローカルリポジトリにあるデータはそちらを優先的に表示する
    const remoteAndLocal =  crossJoin(
      localItems, local => local.localRepositoryItemKey,
      remoteItems, remote => remote.localRepositoryItemKey,
    ).map<AggregateType.RowTypeDisplayData>(pair => pair.left ?? pair.right)

    return remoteAndLocal

  }, [editRange, get, post, queryToTable, openCursor])

  /** 引数に渡されたデータをローカルリポジトリに登録します。 */
  const commit = useCallback(async (...items: AggregateType.RowTypeDisplayData[]) => {
    for (const newValue of items) {
      if (newValue.willBeDeleted && !newValue.existsInRemoteRepository) {
        await queryToTable(table => table.delete(['RowType', newValue.localRepositoryItemKey]))

      } else if (newValue.willBeChanged || newValue.willBeDeleted) {
        await queryToTable(table => table.put({
          dataTypeKey: 'RowType',
          itemKey: newValue.localRepositoryItemKey,
          itemName: `${newValue.own_members?.ID}`,
          item: newValue,
          existsInRemoteRepository: newValue.existsInRemoteRepository,
          willBeChanged: newValue.willBeChanged,
          willBeDeleted: newValue.willBeDeleted,
        }))
      }
    }

    await reloadContext() // 更新があったことをサイドメニューに知らせる
  }, [reloadContext, queryToTable])

  return {
    ready: ready2,
    load,
    commit,
  }
}
/** Rowデータの読み込みと保存を行います。 */
export const useRowRepository = (editRange?
  // データ新規作成の場合
  : ItemKey
  // 複数件編集の場合
  | { filter: AggregateType.RowSearchCondition, skip?: number, take?: number }
  // 1件編集の場合
  | [ID: string | undefined]
) => {

  const [, dispatchMsg] = useMsgContext()
  const { get, post } = useHttpRequest()
  const { reload: reloadContext } = useLocalRepositoryContext()
  const { ready: ready2, openCursor, queryToTable } = useIndexedDbLocalRepositoryTable()

  const load = useCallback(async (): Promise<AggregateType.RowDisplayData[] | undefined> => {
    if (!ready2) return
    if (editRange === undefined) return // 画面表示直後の検索条件が決まっていない場合など


    let remoteItems: AggregateType.RowDisplayData[]
    let localItems: AggregateType.RowDisplayData[]

    if (typeof editRange === 'string') {
      // 新規作成データの検索。
      // まだリモートに存在しないためローカルにのみ検索をかける
      remoteItems = []
      const found = await queryToTable(table => table.get(['Row', editRange]))
      localItems = found ? [found.item as AggregateType.RowDisplayData] : []

    } else if (Array.isArray(editRange)) {
      // 既存データのキーによる検索（リモートリポジトリ）
      if (editRange[0] === undefined) {
        remoteItems = []
      } else {
        const res = await get(`/api/Row/detail/${window.encodeURI(editRange[0].toString())}`)
        remoteItems = res.ok
          ? [res.data as AggregateType.RowDisplayData]
          : []
      }

      // 既存データのキーによる検索（ローカルリポジトリ）
      const itemKey = JSON.stringify(editRange)
      const found = await queryToTable(table => table.get(['Row', itemKey]))
      localItems = found ? [found.item as AggregateType.RowDisplayData] : []

    } else {
      // 既存データの検索条件による検索（リモートリポジトリ）
      const searchParam = new URLSearchParams()
      if (editRange.skip !== undefined) searchParam.append('skip', editRange.skip.toString())
      if (editRange.take !== undefined) searchParam.append('take', editRange.take.toString())
      const url = `/api/Row/load?${searchParam}`
      const res = await post<AggregateType.RowDisplayData[]>(url, editRange.filter)
      remoteItems = res.ok ? res.data : []

      // 既存データの検索条件による検索（ローカルリポジトリ）
      localItems = []
      await openCursor('readonly', cursor => {
        if (cursor.value.dataTypeKey !== 'Row') return
        // TODO: ローカルリポジトリのデータは参照先のキーと名前しか持っていないのでfilterでそれらが検索条件に含まれていると正確な範囲がとれない
        // const item = cursor.value.item as AggregateType.RowDisplayData
        // if (editRange.filter.ID !== undefined
        //   && item.ID !== editRange.filter.ID) return
        // if (editRange.filter.Parent !== undefined
        //   && item.Parent !== editRange.filter.Parent) return
        // if (editRange.filter.Label !== undefined
        //   && item.Label !== editRange.filter.Label) return
        // if (editRange.filter.RowType?.ID !== undefined
        //   && item.RowType?.ID !== editRange.filter.RowType.ID) return
        localItems.push(cursor.value.item as AggregateType.RowDisplayData)
      })
    }

    // ローカルリポジトリにあるデータはそちらを優先的に表示する
    const remoteAndLocal =  crossJoin(
      localItems, local => local.localRepositoryItemKey,
      remoteItems, remote => remote.localRepositoryItemKey,
    ).map<AggregateType.RowDisplayData>(pair => pair.left ?? pair.right)

    return remoteAndLocal

  }, [editRange, get, post, queryToTable, openCursor])

  /** 引数に渡されたデータをローカルリポジトリに登録します。 */
  const commit = useCallback(async (...items: AggregateType.RowDisplayData[]) => {
    for (const newValue of items) {
      if (newValue.willBeDeleted && !newValue.existsInRemoteRepository) {
        await queryToTable(table => table.delete(['Row', newValue.localRepositoryItemKey]))

      } else if (newValue.willBeChanged || newValue.willBeDeleted) {
        await queryToTable(table => table.put({
          dataTypeKey: 'Row',
          itemKey: newValue.localRepositoryItemKey,
          itemName: `${newValue.own_members?.Label}`,
          item: newValue,
          existsInRemoteRepository: newValue.existsInRemoteRepository,
          willBeChanged: newValue.willBeChanged,
          willBeDeleted: newValue.willBeDeleted,
        }))
      }
    }

    await reloadContext() // 更新があったことをサイドメニューに知らせる
  }, [reloadContext, queryToTable])

  return {
    ready: ready2,
    load,
    commit,
  }
}
