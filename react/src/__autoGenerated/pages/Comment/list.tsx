import React, { useCallback, useEffect, useMemo, useRef, useState, useReducer } from 'react'
import { Link } from 'react-router-dom'
import { useFieldArray, FormProvider } from 'react-hook-form'
import { BookmarkSquareIcon, PencilIcon, XMarkIcon, PlusIcon } from '@heroicons/react/24/outline'
import dayjs from 'dayjs'
import { UUID } from 'uuidjs'
import * as Util from '../../util'
import * as Input from '../../input'
import * as Layout from '../../collection'
import * as AggregateType from '../../autogenerated-types'

const VForm = Layout.VerticalForm

export default function () {
  return (
    <Util.MsgContextProvider>
      <Page />
    </Util.MsgContextProvider>
  )
}

const Page = () => {
  const [, dispatchMsg] = Util.useMsgContext()
  const [, dispatchToast] = Util.useToastContext()
  const { get } = Util.useHttpRequest()

  // 検索条件
  const [filter, setFilter] = useState<AggregateType.CommentSearchCondition>(() => AggregateType.createCommentSearchCondition())
  const [currentPage, dispatchPaging] = useReducer(pagingReducer, { pageIndex: 0 })

  const rhfSearchMethods = Util.useFormEx<AggregateType.CommentSearchCondition>({})
  const getConditionValues = rhfSearchMethods.getValues
  const registerExCondition = rhfSearchMethods.registerEx

  // 編集対象（リモートリポジトリ + ローカルリポジトリ）
  const editRange = useMemo(() => ({
    filter,
    skip: currentPage.pageIndex * 20,
    take: 20,
  }), [filter, currentPage])
  const { load, commit } = Util.useCommentRepository(editRange)

  const reactHookFormMethods = Util.useFormEx<{ currentPageItems: GridRow[] }>({})
  const { control, registerEx, handleSubmit, reset } = reactHookFormMethods
  const { fields, append, update, remove } = useFieldArray({ name: 'currentPageItems', control })

  // 画面表示時、再読み込み時
  useEffect(() => {
    load().then(currentPageItems => {
      if (currentPageItems) {
        reset({ currentPageItems })
      }
    })
  }, [load])

  const handleReload = useCallback(() => {
    setFilter(getConditionValues())
  }, [getConditionValues])

  // データ編集
  const handleAdd: React.MouseEventHandler<HTMLButtonElement> = useCallback(async () => {
    const newRow: AggregateType.CommentDisplayData = {
      localRepositoryItemKey: JSON.stringify(UUID.generate()) as Util.ItemKey,
      existsInRemoteRepository: false,
      willBeChanged: true,
      willBeDeleted: false,
      own_members: {
        ID: UUID.generate(),
        Target: 'CommentTargetRow',
      },
    }
    append(newRow)
  }, [append])

  const handleUpdateRow = useCallback(async (index: number, row: GridRow) => {
    update(index, { ...row, willBeChanged: true })
  }, [update])

  const dtRef = useRef<Layout.DataTableRef<GridRow>>(null)
  const handleRemove: React.MouseEventHandler<HTMLButtonElement> = useCallback(async () => {
    if (!dtRef.current) return
    for (const { row, rowIndex } of dtRef.current.getSelectedRows()) {
      update(rowIndex, { ...row, willBeDeleted: true })
    }
  }, [update])

  // データの一時保存
  const onSave = useCallback(async () => {
    await commit(...fields)
    const currentPageItems = await load()
    if (currentPageItems) reset({ currentPageItems })
  }, [commit, load, fields])

  // 列定義
  const columnDefs: Layout.ColumnDefEx<GridRow>[] = useMemo(() => [
    {
      id: 'col-header',
      header: '',
      cell: cellProps => {
        const row = cellProps.row.original
        const state = Util.getLocalRepositoryState(row)
        const singleViewUrl = Util.getCommentSingleViewUrl(row.localRepositoryItemKey, state === '+' ? 'new' : 'edit')
        return (
          <div className="flex items-center gap-1 pl-1">
            <Link to={singleViewUrl} className="text-link">詳細</Link>
            <span className="inline-block w-4 text-center">{state}</span>
          </div>
        )
      },
      size: 64,
      enableResizing: false,
    },
    {
      id: 'col1',
      header: 'Text',
      cell: cellProps => {
        const value = cellProps.row.original.own_members?.Text
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: row => row.own_members?.Text,
      editSetting: {
        type: 'text',
        getTextValue: row => row.own_members?.Text,
        setTextValue: (row, value) => {
          row.own_members.Text = value
        },
      },
    },
    {
      id: 'col2',
      header: 'Author',
      cell: cellProps => {
        const value = cellProps.row.original.own_members?.Author
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: row => row.own_members?.Author,
      editSetting: {
        type: 'text',
        getTextValue: row => row.own_members?.Author,
        setTextValue: (row, value) => {
          row.own_members.Author = value
        },
      },
    },
    {
      id: 'col3',
      header: 'Indent',
      cell: cellProps => {
        const value = cellProps.row.original.own_members?.Indent
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: row => {
        const value = row.own_members?.Indent
        const formatted = value?.toString()
        return formatted
      },
      editSetting: {
        type: 'text',
        getTextValue: row => {
          const value = row.own_members?.Indent
          const formatted = value?.toString()
          return formatted
        },
        setTextValue: (row, value) => {
          const { num: formatted } = Util.tryParseAsNumberOrEmpty(value)
          row.own_members.Indent = formatted
        },
      },
    },
    {
      id: 'col4',
      header: 'Order',
      cell: cellProps => {
        const value = cellProps.row.original.own_members?.Order
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: row => {
        const value = row.own_members?.Order
        const formatted = value?.toString()
        return formatted
      },
      editSetting: {
        type: 'text',
        getTextValue: row => {
          const value = row.own_members?.Order
          const formatted = value?.toString()
          return formatted
        },
        setTextValue: (row, value) => {
          const { num: formatted } = Util.tryParseAsNumberOrEmpty(value)
          row.own_members.Order = formatted
        },
      },
    },
    {
      id: 'col5',
      header: 'CreatedOn',
      cell: cellProps => {
        const value = cellProps.row.original.own_members?.CreatedOn
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: row => row.own_members?.CreatedOn,
      editSetting: {
        type: 'text',
        getTextValue: row => row.own_members?.CreatedOn,
        setTextValue: (row, value) => {
          const { result: formatted } = Util.tryParseAsDateTimeOrEmpty(value)
          row.own_members.CreatedOn = formatted
        },
      },
    },
    {
      id: 'col6',
      header: 'UpdatedOn',
      cell: cellProps => {
        const value = cellProps.row.original.own_members?.UpdatedOn
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: row => row.own_members?.UpdatedOn,
      editSetting: {
        type: 'text',
        getTextValue: row => row.own_members?.UpdatedOn,
        setTextValue: (row, value) => {
          const { result: formatted } = Util.tryParseAsDateTimeOrEmpty(value)
          row.own_members.UpdatedOn = formatted
        },
      },
    },
    {
      id: 'col7',
      header: 'Target',
      cell: cellProps => {
        const value = cellProps.row.original.own_members?.Target
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: row => row.own_members?.Target,
      editSetting: ({
        type: 'combo',
        getValueFromRow: row => row.own_members?.Target,
        setValueToRow: (row, value) => {
          row.own_members.Target = value
        },
        comboProps: {
          options: ['CommentTargetRow' as const, 'CommentTargetCell' as const, 'CommentTargetRowType' as const, 'CommentTargetColumn' as const],
          emitValueSelector: opt => opt,
          matchingKeySelectorFromEmitValue: value => value,
          matchingKeySelectorFromOption: opt => opt,
          textSelector: opt => opt,
        },
      } as Layout.ColumnEditSetting<GridRow, 'CommentTargetRow' | 'CommentTargetCell' | 'CommentTargetRowType' | 'CommentTargetColumn'>) as Layout.ColumnEditSetting<GridRow, unknown>,
    },
  ], [get, update])

  return (
    <div className="page-content-root gap-4">

      <FormProvider {...rhfSearchMethods}>
        <form className="flex flex-col gap-2">
          <div className="flex gap-2 justify-start">
            <h1 className="text-base font-semibold select-none py-1">
              Comment
            </h1>
            <Input.Button onClick={handleReload}>再読み込み</Input.Button>
            <div className="basis-4"></div>
            <Input.Button onClick={handleAdd}>追加</Input.Button>
            <Input.Button onClick={handleRemove}>削除</Input.Button>
            <Input.IconButton fill icon={BookmarkSquareIcon} onClick={onSave}>一時保存</Input.IconButton>
          </div>

          <Util.InlineMessageList />

          <VForm.Container leftColumnMinWidth="10rem">
            <VForm.Item label="Text">
              <Input.Description {...registerExCondition(`Text`)} />
            </VForm.Item>
            <VForm.Item label="Author">
              <Input.Word {...registerExCondition(`Author`)} />
            </VForm.Item>
            <VForm.Item label="Indent">
              <Input.Num {...registerExCondition(`Indent.From`)} />
              <span className="select-none">～</span>
              <Input.Num {...registerExCondition(`Indent.To`)} />
            </VForm.Item>
            <VForm.Item label="Order">
              <Input.Num {...registerExCondition(`Order.From`)} />
              <span className="select-none">～</span>
              <Input.Num {...registerExCondition(`Order.To`)} />
            </VForm.Item>
            <VForm.Item label="CreatedOn">
              <Input.Date {...registerExCondition(`CreatedOn.From`)} />
              <span className="select-none">～</span>
              <Input.Date {...registerExCondition(`CreatedOn.To`)} />
            </VForm.Item>
            <VForm.Item label="UpdatedOn">
              <Input.Date {...registerExCondition(`UpdatedOn.From`)} />
              <span className="select-none">～</span>
              <Input.Date {...registerExCondition(`UpdatedOn.To`)} />
            </VForm.Item>
            <VForm.Item label="Target">
              <label className="inline-flex items-center">
                <Input.CheckBox {...registerExCondition(`Target_CommentTargetRow`)} />
                CommentTargetRow
              </label>
              <label className="inline-flex items-center">
                <Input.CheckBox {...registerExCondition(`Target_CommentTargetCell`)} />
                CommentTargetCell
              </label>
              <label className="inline-flex items-center">
                <Input.CheckBox {...registerExCondition(`Target_CommentTargetRowType`)} />
                CommentTargetRowType
              </label>
              <label className="inline-flex items-center">
                <Input.CheckBox {...registerExCondition(`Target_CommentTargetColumn`)} />
                CommentTargetColumn
              </label>
            </VForm.Item>
          </VForm.Container>
        </form>
      </FormProvider>

      <FormProvider {...reactHookFormMethods}>
        <form className="flex-1">
          <Layout.DataTable
            data={fields}
            columns={columnDefs}
            onChangeRow={handleUpdateRow}
            ref={dtRef}
            className="h-full"
          ></Layout.DataTable>
        </form>
      </FormProvider>
    </div>
  )
}

type GridRow = AggregateType.CommentDisplayData

// TODO: utilに持っていく
type PageState = { pageIndex: number, loaded?: boolean }
const pagingReducer = Util.defineReducer((state: PageState) => ({
  loadComplete: () => ({ pageIndex: state.pageIndex, loaded: true }),
  nextPage: () => ({ pageIndex: state.pageIndex + 1, loaded: false }),
  prevPage: () => ({ pageIndex: Math.max(0, state.pageIndex - 1), loaded: false }),
  moveTo: (pageIndex: number) => ({ pageIndex, loaded: false }),
}))
