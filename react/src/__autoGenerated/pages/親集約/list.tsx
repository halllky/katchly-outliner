import React, { useCallback, useEffect, useMemo, useRef, useState, useReducer } from 'react'
import { Link } from 'react-router-dom'
import { useFieldArray, FormProvider } from 'react-hook-form'
import { BookmarkSquareIcon, PencilIcon, XMarkIcon, PlusIcon } from '@heroicons/react/24/outline'
import dayjs from 'dayjs'
import { UUID } from 'uuidjs'
import * as Util from '../../util'
import * as Input from '../../input'
import * as Layout from '../../collection'
import * as AggregateType from '../../autogenerated-types'

const VForm = Layout.VerticalForm

export default function () {
  return (
    <Util.MsgContextProvider>
      <Page />
    </Util.MsgContextProvider>
  )
}

const Page = () => {
  const [, dispatchMsg] = Util.useMsgContext()
  const [, dispatchToast] = Util.useToastContext()

  // 検索条件
  const [filter, setFilter] = useState<AggregateType.親集約SearchCondition>(() => AggregateType.create親集約SearchCondition())
  const [currentPage, dispatchPaging] = useReducer(pagingReducer, { pageIndex: 0 })

  const rhfSearchMethods = Util.useFormEx<AggregateType.親集約SearchCondition>({})
  const getConditionValues = rhfSearchMethods.getValues
  const registerExCondition = rhfSearchMethods.registerEx

  // 編集対象（リモートリポジトリ + ローカルリポジトリ）
  const editRange = useMemo(() => ({
    filter,
    skip: currentPage.pageIndex * 20,
    take: 20,
  }), [filter, currentPage])
  const { load, commit } = Util.use親集約Repository(editRange)

  const reactHookFormMethods = Util.useFormEx<{ currentPageItems: GridRow[] }>({})
  const { control, registerEx, handleSubmit, reset } = reactHookFormMethods
  const { fields, append, update, remove } = useFieldArray({ name: 'currentPageItems', control })

  // 画面表示時、再読み込み時
  useEffect(() => {
    load().then(currentPageItems => {
      if (currentPageItems) {
        reset({ currentPageItems })
      }
    })
  }, [load])

  const handleReload = useCallback(() => {
    setFilter(getConditionValues())
  }, [getConditionValues])

  // データ編集
  const handleAdd: React.MouseEventHandler<HTMLButtonElement> = useCallback(async () => {
    const newRow: AggregateType.親集約DisplayData = {
      localRepositoryItemKey: JSON.stringify(UUID.generate()) as Util.ItemKey,
      existsInRemoteRepository: false,
      willBeChanged: true,
      willBeDeleted: false,
      own_members: {
        ID: UUID.generate(),
      },
    }
    append(newRow)
  }, [append])

  const handleUpdateRow = useCallback(async (index: number, row: GridRow) => {
    update(index, { ...row, willBeChanged: true })
  }, [update])

  const dtRef = useRef<Layout.DataTableRef<GridRow>>(null)
  const handleRemove: React.MouseEventHandler<HTMLButtonElement> = useCallback(async () => {
    if (!dtRef.current) return
    for (const { row, rowIndex } of dtRef.current.getSelectedRows()) {
      update(rowIndex, { ...row, willBeDeleted: true })
    }
  }, [update])

  // データの一時保存
  const onSave = useCallback(async () => {
    await commit(...fields)
    const currentPageItems = await load()
    if (currentPageItems) reset({ currentPageItems })
  }, [commit, load, fields])

  // 列定義
  const columnDefs: Layout.ColumnDefEx<Util.TreeNode<GridRow>>[] = useMemo(() => [
    {
      id: 'col-header',
      header: '',
      cell: cellProps => {
        const row = cellProps.row.original.item
        const state = Util.getLocalRepositoryState(row)
        const singleViewUrl = Util.get親集約SingleViewUrl(row.localRepositoryItemKey, state === '+' ? 'new' : 'edit')
        return (
          <div className="flex items-center gap-1 pl-1">
            <Link to={singleViewUrl} className="text-link">詳細</Link>
            <span className="inline-block w-4 text-center">{state}</span>
          </div>
        )
      },
      size: 64,
      enableResizing: false,
    },
    {
      id: 'col1',
      header: '単語',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.単語
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.単語,
      setValue: (row, value) => row.item.own_members.単語 = value,
      cellEditor: (props, ref) => <Input.Word ref={ref} {...props} />,
    },
    {
      id: 'col2',
      header: '文章',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.文章
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.文章,
      setValue: (row, value) => row.item.own_members.文章 = value,
      cellEditor: (props, ref) => <Input.Description ref={ref} {...props} />,
    },
    {
      id: 'col3',
      header: '整数',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.整数
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.整数,
      setValue: (row, value) => row.item.own_members.整数 = value,
      cellEditor: (props, ref) => <Input.Num ref={ref} {...props} />,
    },
    {
      id: 'col4',
      header: '実数',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.実数
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.実数,
      setValue: (row, value) => row.item.own_members.実数 = value,
      cellEditor: (props, ref) => <Input.Num ref={ref} {...props} />,
    },
    {
      id: 'col5',
      header: '日付時刻',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.日付時刻
        const formatted = value == undefined
          ? ''
          : dayjs(value).format('YYYY-MM-DD HH:mm:ss')
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {formatted}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.日付時刻,
      setValue: (row, value) => row.item.own_members.日付時刻 = value,
      cellEditor: (props, ref) => <Input.Date ref={ref} {...props} />,
    },
    {
      id: 'col6',
      header: '日付',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.日付
        const formatted = value == undefined
          ? ''
          : dayjs(value).format('YYYY-MM-DD')
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {formatted}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.日付,
      setValue: (row, value) => row.item.own_members.日付 = value,
      cellEditor: (props, ref) => <Input.Date ref={ref} {...props} />,
    },
    {
      id: 'col7',
      header: '年月',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.年月
        let formatted = ''
        if (value != undefined) {
          const yyyy = (Math.floor(value / 100)).toString().padStart(4, '0')
          const mm = (value % 100).toString().padStart(2, '0')
          formatted = `${yyyy}-${mm}`
        }
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {formatted}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.年月,
      setValue: (row, value) => row.item.own_members.年月 = value,
      cellEditor: (props, ref) => <Input.YearMonth ref={ref} {...props} />,
    },
    {
      id: 'col8',
      header: '年',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.年
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.年,
      setValue: (row, value) => row.item.own_members.年 = value,
      cellEditor: (props, ref) => <Input.Num ref={ref} {...props} />,
    },
    {
      id: 'col9',
      header: '参照',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.参照
        const formatted = `${value?.Name ?? ''}`
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {formatted}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.参照,
      setValue: (row, value) => row.item.own_members.参照 = value,
      cellEditor: (props, ref) => <Input.ComboBox参照先 ref={ref} {...props} />,
    },
    {
      id: 'col10',
      header: '真偽値',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.真偽値
        const formatted = (value === undefined ? '' : (value ? '○' : '-'))
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {formatted}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.真偽値,
      setValue: (row, value) => row.item.own_members.真偽値 = value,
      cellEditor: (props, ref) => <Input.BooleanComboBox ref={ref} {...props} />,
    },
    {
      id: 'col11',
      header: '列挙体',
      cell: cellProps => {
        const value = cellProps.row.original.item.own_members?.列挙体
        return (
          <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
            {value}
            &nbsp; {/* <= すべての値が空の行がつぶれるのを防ぐ */}
          </span>
        )
      },
      accessorFn: data => data.item.own_members?.列挙体,
      setValue: (row, value) => row.item.own_members.列挙体 = value,
      cellEditor: (props, ref) => <Input.ComboBox ref={ref} {...props} options={['選択肢1' as const, '選択肢2' as const, '選択肢3' as const]} keySelector={item => item} textSelector={item => item} />,
    },
  ], [update])

  return (
    <div className="page-content-root gap-4">

      <FormProvider {...rhfSearchMethods}>
        <form className="flex flex-col gap-2">
          <div className="flex gap-2 justify-start">
            <h1 className="text-base font-semibold select-none py-1">
              親集約
            </h1>
            <Input.Button onClick={handleReload}>再読み込み</Input.Button>
            <div className="basis-4"></div>
            <Input.Button onClick={handleAdd}>追加</Input.Button>
            <Input.Button onClick={handleRemove}>削除</Input.Button>
            <Input.IconButton fill icon={BookmarkSquareIcon} onClick={onSave}>一時保存</Input.IconButton>
          </div>

          <Util.InlineMessageList />

          <VForm.Container leftColumnMinWidth="10rem">
            <VForm.Item label="単語">
              <Input.Word {...registerExCondition(`単語`)} />
            </VForm.Item>
            <VForm.Item label="文章">
              <Input.Description {...registerExCondition(`文章`)} />
            </VForm.Item>
            <VForm.Item label="整数">
              <Input.Num {...registerExCondition(`整数.From`)} />
              <span className="select-none">～</span>
              <Input.Num {...registerExCondition(`整数.To`)} />
            </VForm.Item>
            <VForm.Item label="実数">
              <Input.Num {...registerExCondition(`実数.From`)} />
              <span className="select-none">～</span>
              <Input.Num {...registerExCondition(`実数.To`)} />
            </VForm.Item>
            <VForm.Item label="日付時刻">
              <Input.Date {...registerExCondition(`日付時刻.From`)} />
              <span className="select-none">～</span>
              <Input.Date {...registerExCondition(`日付時刻.To`)} />
            </VForm.Item>
            <VForm.Item label="日付">
              <Input.Date {...registerExCondition(`日付.From`)} />
              <span className="select-none">～</span>
              <Input.Date {...registerExCondition(`日付.To`)} />
            </VForm.Item>
            <VForm.Item label="年月">
              <Input.YearMonth {...registerExCondition(`年月.From`)} />
              <span className="select-none">～</span>
              <Input.YearMonth {...registerExCondition(`年月.To`)} />
            </VForm.Item>
            <VForm.Item label="年">
              <Input.Num {...registerExCondition(`年.From`)} />
              <span className="select-none">～</span>
              <Input.Num {...registerExCondition(`年.To`)} />
            </VForm.Item>
            <VForm.Item label="真偽値">
              <Input.CheckBox {...registerExCondition(`真偽値`)} />
            </VForm.Item>
            <VForm.Item label="列挙体">
              <Input.Selection {...registerExCondition(`列挙体`)} options={['選択肢1' as const, '選択肢2' as const, '選択肢3' as const]} keySelector={item => item} textSelector={item => item} />
            </VForm.Item>
            <VForm.Container label="参照先">
              <VForm.Item label="Name">
                <Input.Word {...registerExCondition(`参照.Name`)} />
              </VForm.Item>
            </VForm.Container>
          </VForm.Container>
        </form>
      </FormProvider>

      <FormProvider {...reactHookFormMethods}>
        <form className="flex-1">
          <Layout.DataTable
            data={fields}
            columns={columnDefs}
            onChangeRow={handleUpdateRow}
            ref={dtRef}
            className="h-full"
          ></Layout.DataTable>
        </form>
      </FormProvider>
    </div>
  )
}

type GridRow = AggregateType.親集約DisplayData

// TODO: utilに持っていく
type PageState = { pageIndex: number, loaded?: boolean }
const pagingReducer = Util.defineReducer((state: PageState) => ({
  loadComplete: () => ({ pageIndex: state.pageIndex, loaded: true }),
  nextPage: () => ({ pageIndex: state.pageIndex + 1, loaded: false }),
  prevPage: () => ({ pageIndex: Math.max(0, state.pageIndex - 1), loaded: false }),
  moveTo: (pageIndex: number) => ({ pageIndex, loaded: false }),
}))
