import { UUID } from 'uuidjs'
import * as Util from './__autoGenerated/util'
import { useCallback } from 'react'
import { useFieldArray } from 'react-hook-form'

const _rowObjectIdSymbol: unique symbol = Symbol()
const _rowTypeIdSymbol: unique symbol = Symbol()
const _ColumnIdSymbol: unique symbol = Symbol()
export type RowObjectId = string & { [_rowObjectIdSymbol]: never }
export type RowTypeId = string & { [_rowTypeIdSymbol]: never }
export type ColumnId = string & { [_ColumnIdSymbol]: never }

export type RowObject = {
  id: RowObjectId
  text: string
  type: RowTypeId
  attrs: { [key: ColumnId]: string }
  indent: number
}
export type RowType = {
  id: RowTypeId
  name?: string
  columns: { id: ColumnId, name?: string }[]
}

export type GridRow = GridRowOfRowObject | GridRowOfRowType
export type GridRowOfRowObject = {
  type: 'row'
  item: RowObject
}
export type GridRowOfRowType = {
  type: 'rowType'
  rowTypeId: RowTypeId
}

// ---------------------------------------------------

export const ROWTYPE_STYLE = 'text-neutral-500 bg-neutral-500/10'

export type PageFormState = {
  gridRows: GridRow[]
}

export const rowTypeMapReducer = Util.defineReducer((state: {
  rowTypeMap: Map<RowTypeId, RowType>
}) => ({
  init: (rowTypes: RowType[]) => ({
    rowTypeMap: new Map(rowTypes.map(t => [t.id, t])),
  }),
  set: (rowType: RowType) => {
    const rowTypeMap = new Map(state.rowTypeMap)
    rowTypeMap.set(rowType.id, rowType)
    return { rowTypeMap }
  },
}))

// ---------------------------------------------------
/** Rowを行順に並べ、RowTypeが変わったタイミングでその行の型を表す行を挿入する */
export const toGridRows = (rowData: RowObject[]): GridRow[] => {
  const gridRows: GridRow[] = []
  for (let i = 0; i < rowData.length; i++) {
    const currentRow = rowData[i]
    const previousRow = i === 0 ? undefined : rowData[i - 1]

    // 行の型が変わったタイミングでRowTypeを表す行を挿入する
    if (previousRow === undefined || currentRow.type !== previousRow.type) {
      gridRows.push({
        type: 'rowType',
        rowTypeId: currentRow.type,
      })
    }

    gridRows.push({
      type: 'row',
      item: currentRow,
    })
  }
  return gridRows
}

// -----------------------------------------
/** 指定範囲の行の再計算 */
export const useRecalculateGridRow = (
  fields: UseFieldArrayReturnType['fields'],
  insert: UseFieldArrayReturnType['insert'],
  update: UseFieldArrayReturnType['update'],
  remove: UseFieldArrayReturnType['remove']
) => {
  return useCallback((recalculateRange: [number, number]) => {
    // ループ処理の始点を決める。行を挿入したり削除したりする都合上、下から順に処理する。
    const min = Math.min(recalculateRange[0], recalculateRange[1], 0)
    const max = Math.max(recalculateRange[0], recalculateRange[1], fields.length - 1)
    const start = getBelowRowObjectIndex(max, fields) ?? (fields.length - 1)
    const end = getAboveRowObjectIndex(min, fields) ?? 0

    // ループ処理
    const removedRowIndexes: number[] = []
    const insertedRows: { aboveOf: GridRowOfRowObject, insertRow: GridRowOfRowType }[] = []
    const updatedRows: { aboveOf: GridRowOfRowObject, updateRow: GridRowOfRowType }[] = []
    let i = start
    while (i >= end) {
      const currentRow = fields[i]
      if (currentRow.type === 'rowType') {
        i--
        continue
      }

      // 現在の行の「直前」の行を取得する。ここでの直前は、現在の行の1行上がRowTypeの行ならばそれをスキップしてその上のこと。
      const aboveRowObjectIndex = getAboveRowObjectIndex(i, fields)
      const aboveRowObject = aboveRowObjectIndex === undefined ? undefined : (fields[aboveRowObjectIndex] as GridRowOfRowObject)

      // 現在の行の1行上にRowTypeの行が本来あるべきか否かと、
      // 実際に現在の行の1行上にRowTypeの行があるかどうかを比較し、
      // RowTypeの行を挿入したり削除したりする。
      if (aboveRowObject === undefined || aboveRowObject.item.type !== currentRow.item.type) {

        // 現在の行の1行上にRowTypeの行が本来あるべきなのに存在しない場合、RowTypeの行を挿入する。
        const actual = fields[i - 1]
        if (actual === undefined || actual.type !== 'rowType') {
          const insertRow: GridRowOfRowType = {
            type: 'rowType',
            rowTypeId: currentRow.item.type,
          }
          insertedRows.push({ aboveOf: currentRow, insertRow })
        }
        // 現在の行の1行上にRowTypeの行があるが、その型が本来あるべき型と違う場合、update
        else if (actual.rowTypeId !== currentRow.item.type) {
          const updateRow: GridRowOfRowType = {
            ...actual,
            rowTypeId: currentRow.item.type,
          }
          updatedRows.push({ aboveOf: currentRow, updateRow })
        }

      } else if (aboveRowObject.item.type === currentRow.item.type) {

        // 現在の行の1行上にRowTypeの行が本来あるべきではないのに存在する場合、そのRowTypeの行を削除する。
        const actual = fields[i - 1]
        if (actual?.type === 'rowType') {
          removedRowIndexes.push(i - 1)
        }
      }

      i--
    }

    // 追加削除の実行
    remove(removedRowIndexes)
    for (const { aboveOf, insertRow } of insertedRows) {
      const index = fields.findIndex(x => x.type === 'row' && x.item.id === aboveOf.item.id)
      insert(index, insertRow)
    }
    for (const { aboveOf, updateRow } of updatedRows) {
      const index = fields.findIndex(x => x.type === 'row' && x.item.id === aboveOf.item.id)
      update(index - 1, updateRow)
    }
  }, [fields, insert, update, remove])
}

export type UseFieldArrayReturnType = ReturnType<typeof useFieldArray<PageFormState, 'gridRows'>>

const getAboveRowObjectIndex = (currentIndex: number, all: GridRow[]): number | undefined => {
  while (currentIndex >= 0) {
    currentIndex--
    if (all[currentIndex]?.type === 'row') return currentIndex
  }
  return undefined
}
const getBelowRowObjectIndex = (currentIndex: number, all: GridRow[]): number | undefined => {
  while (currentIndex <= all.length - 1) {
    currentIndex++
    if (all[currentIndex]?.type === 'row') return currentIndex
  }
  return undefined
}
// -----------------------------------------

export const insertNewRow = (aboveRow: GridRow): GridRowOfRowObject => {
  const type = aboveRow?.type === 'row'
    ? aboveRow.item.type
    : aboveRow?.rowTypeId
  const indent = aboveRow?.type === 'row'
    ? aboveRow.item.indent
    : 0
  return {
    type: 'row',
    item: {
      id: UUID.generate() as RowObjectId,
      text: '',
      type: type,
      attrs: {},
      indent,
    },
  }
}

/** ラベル列のセルの値取得 */
export const getLabelCellValue = (gridRow: GridRow, rowTypeMap: Map<RowTypeId, RowType>): string | undefined => {
  if (gridRow.type === 'row') {
    return gridRow.item.text
  } else {
    return rowTypeMap.get(gridRow.rowTypeId)?.name
  }
}

/** ラベル列のセルの値設定 */
export const setLabelCellValue = (gridRow: GridRow, rowTypeMap: Map<RowTypeId, RowType>, value: string | undefined): { updatedRowType?: RowType } => {
  if (gridRow.type === 'row') {
    gridRow.item.text = value ?? ''
  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    if (rowType) {
      rowType.name = value
      return { updatedRowType: rowType }
    }
  }
  return {}
}

/** Attr列のセルの値取得 */
export const getAttrCellValue = (gridRow: GridRow, rowTypeMap: Map<RowTypeId, RowType>, colIndex: number): string | undefined => {
  if (gridRow.type === 'row') {
    const rowType = rowTypeMap.get(gridRow.item.type)
    if (rowType === undefined) return undefined
    const colTypeId = rowType.columns[colIndex]?.id
    if (colTypeId === undefined) return undefined
    return gridRow.item.attrs[colTypeId]

  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    if (rowType === undefined) return undefined
    return rowType.columns[colIndex]?.name
  }
}

/** Attr列のセルの値設定 */
export const setAttrCellValue = (
  gridRow: GridRow,
  rowTypeMap: Map<RowTypeId, RowType>,
  colIndex: number,
  value: string | undefined
): ({ updatedRowType?: RowType }) => {

  const rowTypeId = gridRow.type === 'row'
    ? gridRow.item.type
    : gridRow.rowTypeId
  const rowType = rowTypeMap.get(rowTypeId)
  if (rowType === undefined) throw new Error(`Row type not found: '${rowTypeId}'`)

  // その列の属性が存在しない場合は新規作成
  const columns = [...rowType.columns]
  let newColumnsAreCreated = false
  while (columns.length - 1 < colIndex) {
    columns.push({ id: UUID.generate() as ColumnId })
    newColumnsAreCreated = true
  }

  if (gridRow.type === 'row') {
    // 保存容量の削減のため、空文字の場合は属性自体を削除する
    const columnId = columns[colIndex].id
    if (value === undefined || value === '') {
      delete gridRow.item.attrs[columnId]
    } else {
      gridRow.item.attrs[columnId] = value
    }

  } else {
    columns[colIndex].name = value
  }

  return newColumnsAreCreated || gridRow.type === 'rowType'
    ? { updatedRowType: { ...rowType, columns } }
    : {}
}
