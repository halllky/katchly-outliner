import { UUID } from 'uuidjs'
import dayjs from 'dayjs'
import * as Util from './__autoGenerated/util'
import { useCallback, useReducer } from 'react'
import { useFieldArray } from 'react-hook-form'

const _rowObjectIdSymbol: unique symbol = Symbol()
const _rowTypeIdSymbol: unique symbol = Symbol()
const _ColumnIdSymbol: unique symbol = Symbol()
export type RowObjectId = string & { [_rowObjectIdSymbol]: never }
export type RowTypeId = string & { [_rowTypeIdSymbol]: never }
export type ColumnId = `["${RowTypeId}", "${string}"]` & { [_ColumnIdSymbol]: never }

export type EditableObject = {
  existsInRemoteRepository: boolean
  willBeChanged: boolean
  willBeDeleted: boolean
}
export type RowObject = EditableObject & {
  id: RowObjectId
  text: string
  type: RowTypeId
  attrs: { [key: ColumnId]: RowObjectAttr }
  indent: number
  createdOn: string
  comments: Comment[]
}
export type RowObjectAttr = {
  value: string
  updatedOn: string
  comments: Comment[]
}
export type RowType = EditableObject & {
  id: RowTypeId
  name?: string
  columns: { id: ColumnId, name?: string, comments: Comment[] }[]
  comments: Comment[]
}

export type GridRow = GridRowOfRowObject | GridRowOfRowType
export type GridRowOfRowObject = {
  type: 'row'
  item: RowObject
}
export type GridRowOfRowType = {
  type: 'rowType'
  rowTypeId: RowTypeId
  indent: number
}

// ---------------------------------------------------

export const ROWTYPE_STYLE = 'text-color-6 bg-color-2'

export type PageFormState = {
  gridRows: GridRow[]
}

const rowTypeMapReducer = Util.defineReducer((state: {
  rowTypeMap: Map<RowTypeId, RowType>
}) => ({
  init: (rowTypes: RowType[]) => ({
    rowTypeMap: new Map(rowTypes.map(t => [t.id, t])),
  }),
  set: (rowType: RowType) => {
    const rowTypeMap = new Map(state.rowTypeMap)
    rowTypeMap.set(rowType.id, rowType)
    return { rowTypeMap }
  },
}))
export const useRowTypeMap = () => {
  return useReducer(rowTypeMapReducer, undefined, () => ({ rowTypeMap: new Map() }))
}
export type RowTypeMapDispatcher = ReturnType<typeof useRowTypeMap>['1']

// ---------------------------------------------------
/** Rowを行順に並べ、RowTypeが変わったタイミングでその行の型を表す行を挿入する */
export const toGridRows = (rowData: RowObject[]): GridRow[] => {
  const gridRows: GridRow[] = []
  let mostShallowIndent = Infinity
  for (let i = rowData.length - 1; i >= 0; i--) {
    const currentRow = rowData[i]
    gridRows.unshift({
      type: 'row',
      item: currentRow,
    })
    if (currentRow.indent < mostShallowIndent) {
      mostShallowIndent = currentRow.indent
    }
    // 行の型が変わるタイミングまたは表の先頭でRowTypeを表す行を挿入する
    if (rowData[i - 1]?.type !== currentRow.type) {
      gridRows.unshift({
        type: 'rowType',
        rowTypeId: currentRow.type,
        indent: mostShallowIndent,
      })
      mostShallowIndent = Infinity
    }
  }
  return gridRows
}

// -----------------------------------------
/** 行範囲編集 */
export const useEditRowObject = (
  fields: UseFieldArrayReturnType['fields'],
  insert: UseFieldArrayReturnType['insert'],
  update: UseFieldArrayReturnType['update'],
  remove: UseFieldArrayReturnType['remove'],
) => {
  return useCallback((range: [number, number], editFunction: (rows: GridRowOfRowObject[]) => GridRowOfRowObject[]) => {
    // 指定範囲の行オブジェクトを編集
    const min = Math.max(Math.min(range[0], range[1]), 0)
    const max = Math.min(Math.max(range[0], range[1]), fields.length - 1)
    const sliced = fields.slice(min, max + 1)
    const onlyRowObject = sliced.filter(r => r.type === 'row') as GridRowOfRowObject[]
    const editedRowObjects = editFunction(onlyRowObject)

    // 指定範囲の1つ外側の行オブジェクトを含める
    const recalculateRange = editedRowObjects
    const above = getAboveRowObjectIndex(min, fields)
    const below = getBelowRowObjectIndex(max, fields)
    if (above !== undefined) recalculateRange.unshift(fields[above] as GridRowOfRowObject)
    if (below !== undefined) recalculateRange.push(fields[below] as GridRowOfRowObject)

    // 編集範囲に表の先頭の行型が含まれる場合
    const udpateFirstRowType = above === undefined

    // 行型を再計算
    const withRowType: GridRow[] = []
    let mostShallowIndent = Infinity
    for (let i = recalculateRange.length - 1; i >= 0; i--) {
      const currentRow = recalculateRange[i]
      withRowType.unshift(currentRow)
      if (currentRow.item.indent < mostShallowIndent) {
        mostShallowIndent = currentRow.item.indent
      }

      // 行型が変化したタイミングで行型を表すデータを挿入する
      if (i >= 1 && recalculateRange[i - 1].item.type !== currentRow.item.type
        || i === 0 && udpateFirstRowType) {
        withRowType.unshift({ type: 'rowType', rowTypeId: currentRow.item.type, indent: mostShallowIndent })
        mostShallowIndent = Infinity
      }
    }

    // 編集範囲内のfieldsを更新
    const updateRangeStartIndex = above ?? 0
    const updateRangeEndIndex = below ?? fields.length - 1
    const itemCountBeforeUpdate = updateRangeEndIndex - updateRangeStartIndex + 1
    const itemCountAfterUpdate = withRowType.length
    const loopEnd = Math.max(itemCountBeforeUpdate, itemCountAfterUpdate)

    for (let i = 0; i < loopEnd; i++) {
      if (i >= itemCountBeforeUpdate) {
        insert(updateRangeStartIndex + i, withRowType.slice(i))
        break

      } else if (i >= itemCountAfterUpdate) {
        const removedIndexes = Array
          .from({ length: loopEnd - i })
          .map((_, j) => i + j + updateRangeStartIndex)
        remove(removedIndexes)
        break

      } else {
        update(updateRangeStartIndex + i, { ...withRowType[i] })
      }
    }

    // 編集範囲外であっても上方の行型の行のインデントは影響を受けることがある
    const updatedFileds = [
      ...fields.slice(0, updateRangeStartIndex),
      ...withRowType,
      ...fields.slice(updateRangeEndIndex + 1),
    ]
    const group = getGroupAt(updateRangeStartIndex, updatedFileds)
    update(group.start, { ...group.rowType, indent: Math.min(...group.rows.map(r => r.item.indent)) })
  }, [fields, insert, update, remove])
}

export type UseFieldArrayReturnType = ReturnType<typeof useFieldArray<PageFormState, 'gridRows'>>

export const getAboveRowObjectIndex = (currentIndex: number, all: GridRow[]): number | undefined => {
  while (currentIndex >= 0) {
    currentIndex--
    if (all[currentIndex]?.type === 'row') return currentIndex
  }
  return undefined
}
export const getBelowRowObjectIndex = (currentIndex: number, all: GridRow[]): number | undefined => {
  while (currentIndex <= all.length - 1) {
    currentIndex++
    if (all[currentIndex]?.type === 'row') return currentIndex
  }
  return undefined
}

type SameRowTypeGroup = {
  rowType: GridRowOfRowType
  rows: GridRowOfRowObject[]
  start: number
  end: number
}
/**
 * 同じ行型の塊のうち最後に現れるグループを返します。
 * @param rowIndex この位置にあるグループを返します。
 * @param allRows 行型が適切な位置に挿入されている前提の配列
 */
const getGroupAt = (rowIndex: number, allRows: GridRow[]): SameRowTypeGroup => {
  // 上方向に走査して行型の行を探す
  let rowType: GridRowOfRowType | undefined = undefined
  let start = rowIndex
  while (start >= 0) {
    const row = allRows[start]
    if (row.type === 'rowType') {
      rowType = row
      break
    }
    start--
  }
  if (rowType === undefined) throw new Error('引数に渡された配列は行型が適切な位置に挿入されていない')
  // 下方向に走査して同じ行型の終わりまで行を集める
  const rows: GridRowOfRowObject[] = []
  let end = start + 1
  while (end < allRows.length) {
    const row = allRows[end]
    if (row.type === 'row') {
      rows.push(row)
    } else {
      break
    }
    end++
  }
  return { rowType, rows, start, end }
}

export const moveArrayItem = <T>(arr: T[], { from, to }: { from: number, to: number }): T[] => {
  const clone = [...arr]
  const movedItem = clone.splice(from, 1)[0]
  clone.splice(to, 0, movedItem)
  return clone
}
// -----------------------------------------

export const createNewRowType = (name?: string, columnNames?: string[]): RowType => ({
  id: UUID.generate() as RowTypeId,
  name,
  columns: columnNames?.map(colName => ({
    id: UUID.generate() as ColumnId,
    name: colName,
    comments: [],
  })) ?? [],
  comments: [],
  existsInRemoteRepository: false,
  willBeChanged: true,
  willBeDeleted: false,
})

export const insertNewRow = (aboveRow: GridRow | undefined): { newRow: GridRowOfRowObject, newRowType: RowType | undefined } => {
  let newRowType: RowType | undefined = undefined
  let type: RowTypeId
  if (aboveRow?.type === 'row') {
    type = aboveRow.item.type

  } else if (aboveRow?.type === 'rowType') {
    type = aboveRow.rowTypeId

  } else {
    // 上の行が無い場合（グリッドが空の場合の新規作成など）は行型もこのタイミングで一緒に作成する
    newRowType = createNewRowType()
    type = newRowType.id
  }

  const newRow: GridRowOfRowObject = {
    type: 'row',
    item: {
      id: UUID.generate() as RowObjectId,
      text: '',
      type,
      attrs: {},
      indent: aboveRow?.type === 'row'
        ? aboveRow.item.indent
        : 0,
      createdOn: '', // どのみちサーバー側で自動設定されるので空文字で初期化する
      existsInRemoteRepository: false,
      willBeChanged: true,
      willBeDeleted: false,
      comments: [],
    },
  }

  return { newRow, newRowType }
}

/** 行の編集状態取得 */
export const getRowEditState = (gridRow: GridRow, rowTypeMap: Map<RowTypeId, RowType>): Util.LocalRepositoryState => {
  if (gridRow.type === 'row') {
    return Util.getLocalRepositoryState(gridRow.item)
  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    return rowType ? Util.getLocalRepositoryState(rowType) : ''
  }
}

/** ラベル列のセルの値取得 */
export const getLabelCellValue = (gridRow: GridRow, rowTypeMap: Map<RowTypeId, RowType>): string | undefined => {
  if (gridRow.type === 'row') {
    return gridRow.item.text
  } else {
    return rowTypeMap.get(gridRow.rowTypeId)?.name
  }
}

/** ラベル列のセルの値設定 */
export const setLabelCellValue = (gridRow: GridRow, rowTypeMap: Map<RowTypeId, RowType>, value: string | undefined): { updatedRowType?: RowType } => {
  if (gridRow.type === 'row') {
    gridRow.item.text = value ?? ''
  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    if (rowType) {
      rowType.name = value
      return { updatedRowType: rowType }
    }
  }
  return {}
}

/** Attr列のセルの値取得 */
export const getAttrCellValue = (gridRow: GridRow, rowTypeMap: Map<RowTypeId, RowType>, colIndex: number): string | undefined => {
  if (gridRow.type === 'row') {
    const rowType = rowTypeMap.get(gridRow.item.type)
    if (rowType === undefined) return undefined
    const colTypeId = rowType.columns[colIndex]?.id
    if (colTypeId === undefined) return undefined
    return gridRow.item.attrs[colTypeId]?.value

  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    if (rowType === undefined) return undefined
    return rowType.columns[colIndex]?.name
  }
}

/** Attr列のセルの値設定 */
export const setAttrCellValue = (
  gridRow: GridRow,
  rowTypeMap: Map<RowTypeId, RowType>,
  colIndex: number,
  value: string | undefined
): ({ updatedRowType?: RowType }) => {

  const rowTypeId = gridRow.type === 'row'
    ? gridRow.item.type
    : gridRow.rowTypeId
  const rowType = rowTypeMap.get(rowTypeId)
  if (rowType === undefined) throw new Error(`Row type not found: '${rowTypeId}'`)

  // その列の属性が存在しない場合は新規作成
  const columns = [...rowType.columns]
  let newColumnsAreCreated = false
  while (columns.length - 1 < colIndex) {
    columns.push({ id: `["${rowTypeId}", "${UUID.generate()}"]` as ColumnId, comments: [] })
    newColumnsAreCreated = true
  }

  if (gridRow.type === 'row') {
    // 保存容量の削減のため、空文字の場合は属性自体を削除する
    const columnId = columns[colIndex].id
    if (value === undefined || value === '') {
      delete gridRow.item.attrs[columnId]
    } else {
      const currentValue = gridRow.item.attrs[columnId]
      gridRow.item.attrs[columnId] = {
        value,
        updatedOn: currentValue?.updatedOn ?? '',
        comments: [],
      }
    }

  } else {
    columns[colIndex].name = value
  }

  return newColumnsAreCreated || gridRow.type === 'rowType'
    ? { updatedRowType: { ...rowType, columns } }
    : {}
}

// -------------------------------------------
// コメント

const _commentIdSymbol: unique symbol = Symbol()
export type CommentId = string & { [_commentIdSymbol]: never }

export type Comment = EditableObject & {
  id: CommentId
  text: string
  author: string
  indent: number
  createdOn: string
  updatedOn: string
}

export const createNewComment = (author: string): Comment => {
  const now = dayjs().format('YYYY-MM-DD HH:mm:ss')
  return {
    id: UUID.generate() as CommentId,
    text: '',
    author,
    indent: 0,
    createdOn: now,
    updatedOn: now,
    existsInRemoteRepository: false,
    willBeChanged: true,
    willBeDeleted: false,
  }
}
