import { useEffect, useMemo, useReducer, useState } from 'react'
import { useFieldArray } from 'react-hook-form'
import * as AggregateTypes from './__autoGenerated/autogenerated-types'
import * as Util from './__autoGenerated/util'
import * as Input from './__autoGenerated/input'
import * as Collection from './__autoGenerated/collection'
import createTestData from './MainPageTestData'

export default function () {

  const { rowTypes, rows } = useMemo(() => {
    return createTestData()
  }, [])

  if (!rowTypes || !rows) return (
    <span>読み込み中...</span>
  )

  return (
    <AfterLoaded
      rowTypeData={rowTypes}
      rowData={rows}
    />
  )
}

const AfterLoaded = ({ rowData, rowTypeData }: {
  rowData: AggregateTypes.RowDisplayData[]
  rowTypeData: AggregateTypes.RowTypeDisplayData[]
}) => {

  // RowType
  const [{ rowTypeMap }, dispatchRowType] = useReducer(rowTypeMapReducer, undefined, () => ({ rowTypeMap: new Map() }))
  useEffect(() => {
    dispatchRowType(state => state.init(rowTypeData))
  }, [rowTypeData])

  // 行
  const { control, reset } = Util.useFormEx<PageFormState>({})
  const { fields, update } = useFieldArray({ control, name: 'gridRows' })
  useEffect(() => {
    reset({ gridRows: toGridRows(rowData) })
  }, [rowData])

  // 列
  const [columnCount, setColumnCount] = useState(4)
  const [indentSize, setIndentSize] = useState(24)
  const columnDefs = useMemo((): Collection.ColumnDefEx<Util.TreeNode<GridRow>>[] => [{
    id: 'col0',
    header: '　',
    cell: cellProps => {
      const value = getLabelCellValue(cellProps.row.original.item, rowTypeMap)
      const style: React.CSSProperties = { marginLeft: cellProps.row.original.item.indent * indentSize }
      return (
        <span className="block w-full px-1 overflow-hidden whitespace-nowrap" style={style}>
          {value}&nbsp;
        </span>
      )
    },
    accessorFn: data => getLabelCellValue(data.item, rowTypeMap),
    setValue: (row, value) => {
      const { updatedRowType } = setLabelCellValue(row.item, rowTypeMap, value)
      if (updatedRowType) dispatchRowType(state => state.set({ ...updatedRowType }))
    },
    cellEditor: (props, ref) => <Input.Word ref={ref} {...props} />,

  }, ...Array.from({ length: columnCount }, (_, i) => i).map<Collection.ColumnDefEx<Util.TreeNode<GridRow>>>(i => ({
    id: `col${i + 1}`,
    header: '　',
    cell: cellProps => {
      const value = getAttrCellValue(cellProps.row.original.item, rowTypeMap, i)
      return (
        <span className="block w-full px-1 overflow-hidden whitespace-nowrap">
          {value}&nbsp;
        </span>
      )
    },
    accessorFn: data => getAttrCellValue(data.item, rowTypeMap, i),
    setValue: (row, value) => {
      const { updatedRowType } = setAttrCellValue(row.item, rowTypeMap, i, value)
      if (updatedRowType) dispatchRowType(state => state.set({ ...updatedRowType }))
    },
    cellEditor: (props, ref) => <Input.Word ref={ref} {...props} />,
  }))], [columnCount, indentSize, rowTypeMap, update, dispatchRowType])

  console.log(fields)

  return (
    <div>
      <Collection.DataTable
        data={fields}
        columns={columnDefs}
        onChangeRow={update}
      />
    </div>
  )
}

// -------------------------------
type GridRow = {
  type: 'row'
  indent: number
  item: AggregateTypes.RowDisplayData
} | {
  type: 'rowType'
  indent: number
  rowTypeId: Util.ItemKey
}

/** Rowを行順に並べ、RowTypeが変わったタイミングでその行の型を表す行を挿入する */
const toGridRows = (rowData: AggregateTypes.RowDisplayData[]): GridRow[] => {
  // 行を順番に並べる
  const sorted = [...rowData]
  sorted.sort((a, b) => {
    const orderA = a.ref_from_Row_RowOrder?.own_members.Order ?? 0
    const orderB = b.ref_from_Row_RowOrder?.own_members.Order ?? 0
    return orderB - orderA
  })

  // インデント計算のためにツリー構造にする
  const tree = Util.toTree(sorted, {
    getId: row => row.localRepositoryItemKey,
    getParent: row => row.own_members.Parent,
  })
  const flattenTree = Util.flatten(tree)

  // GridRowを組み立てる
  const gridRows: GridRow[] = []
  for (let i = 0; i < flattenTree.length; i++) {
    const currentRow = flattenTree[i]
    const previousRow = i === 0 ? undefined : flattenTree[i - 1]

    // RowTypeを表す行を挿入する
    if (previousRow === undefined || currentRow.item.own_members.RowType?.__instanceKey !== previousRow.item.own_members.RowType?.__instanceKey) {
      if (currentRow.item.own_members.RowType?.__instanceKey === undefined) throw new Error('RowType is undefined!')
      gridRows.push({
        type: 'rowType',
        indent: currentRow.depth,
        rowTypeId: currentRow.item.own_members.RowType.__instanceKey,
      })
    }

    // Rowを挿入する
    gridRows.push({
      type: 'row',
      indent: currentRow.depth,
      item: currentRow.item,
    })
  }
  return gridRows
}

/** ラベル列のセルの値取得 */
const getLabelCellValue = (gridRow: GridRow, rowTypeMap: Map<Util.ItemKey, AggregateTypes.RowTypeDisplayData>): string | undefined => {
  if (gridRow.type === 'row') {
    return gridRow.item.own_members.Label
  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    return rowType?.own_members.RowTypeName
  }
}

/** ラベル列のセルの値設定 */
const setLabelCellValue = (gridRow: GridRow, rowTypeMap: Map<Util.ItemKey, AggregateTypes.RowTypeDisplayData>, value: string | undefined): { updatedRowType?: AggregateTypes.RowTypeDisplayData } => {
  if (gridRow.type === 'row') {
    gridRow.item.own_members.Label = value
  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    if (rowType) {
      rowType.own_members.RowTypeName = value
      return { updatedRowType: rowType }
    }
  }
  return {}
}

/** Attr列のセルの値取得 */
const getAttrCellValue = (gridRow: GridRow, rowTypeMap: Map<Util.ItemKey, AggregateTypes.RowTypeDisplayData>, colIndex: number): string | undefined => {
  if (gridRow.type === 'row') {
    if (gridRow.item.own_members.RowType?.__instanceKey === undefined) return undefined
    const rowType = rowTypeMap.get(gridRow.item.own_members.RowType.__instanceKey)
    if (rowType === undefined) return undefined
    const colTypeId = rowType.child_Columns?.[colIndex]?.localRepositoryItemKey
    if (colTypeId === undefined) return undefined
    const attribute = gridRow.item.child_Attrs?.find(attr => attr.own_members.ColType?.__instanceKey === colTypeId)
    return attribute?.own_members.Value

  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    if (rowType === undefined) return undefined
    const column = rowType.child_Columns?.[colIndex]
    return column?.own_members.ColumnName
  }
}

/** Attr列のセルの値設定 */
const setAttrCellValue = (
  gridRow: GridRow,
  rowTypeMap: Map<Util.ItemKey, AggregateTypes.RowTypeDisplayData>,
  colIndex: number,
  value: string | undefined): ({ updatedRowType?: AggregateTypes.RowTypeDisplayData }) => {
  if (gridRow.type === 'row') {
    if (gridRow.item.own_members.RowType?.__instanceKey === undefined) return {}
    const rowType = rowTypeMap.get(gridRow.item.own_members.RowType.__instanceKey)
    if (rowType === undefined) return {}
    const colTypeId = rowType.child_Columns?.[colIndex]?.localRepositoryItemKey
    if (colTypeId === undefined) return {}
    const attribute = gridRow.item.child_Attrs?.find(attr => attr.own_members.ColType?.__instanceKey === colTypeId)
    if (attribute === undefined) return {}
    attribute.own_members.Value = value

  } else {
    const rowType = rowTypeMap.get(gridRow.rowTypeId)
    if (rowType === undefined) return {}
    const column = rowType.child_Columns?.[colIndex]
    if (column) {
      column.own_members.ColumnName = value
      return { updatedRowType: rowType }
    }
  }
  return {}
}

// -------------------------------
type PageFormState = {
  gridRows: GridRow[]
}

// -------------------------------
const rowTypeMapReducer = Util.defineReducer((state: {
  rowTypeMap: Map<Util.ItemKey, AggregateTypes.RowTypeDisplayData>
}) => ({
  init: (rowTypes: AggregateTypes.RowTypeDisplayData[]) => ({
    rowTypeMap: new Map(rowTypes.map(t => [t.localRepositoryItemKey, t])),
  }),
  set: (rowType: AggregateTypes.RowTypeDisplayData) => {
    const rowTypeMap = new Map(state.rowTypeMap)
    rowTypeMap.set(rowType.localRepositoryItemKey, rowType)
    return { rowTypeMap }
  },
}))
