import React, { useCallback, useEffect, useMemo, useReducer, useRef, useState } from 'react'
import { useFieldArray } from 'react-hook-form'
import * as Util from './__autoGenerated/util'
import * as Input from './__autoGenerated/input'
import * as Collection from './__autoGenerated/collection'
import createTestData from './MainPageTestData'
import { GridRow, RowObject, RowType, RowTypeId, getAttrCellValue, getLabelCellValue, insertNewRow, setAttrCellValue, setLabelCellValue, toGridRows } from './Types'
import { PlusIcon, TrashIcon } from '@heroicons/react/24/solid'

export default function () {

  const [many, setMany] = useState<boolean | undefined>(true)
  const { rowTypes, rows } = useMemo(() => {
    return createTestData(many ?? false)
  }, [many])
  const debugStyle = useMemo((): React.CSSProperties => ({
    fontFamily: '"BIZ UDGothic"',
  }), [])

  if (!rowTypes || !rows) return (
    <span>読み込み中...</span>
  )

  return (
    <AfterLoaded
      rowTypeData={rowTypes}
      rowData={rows}
      className="p-1 h-full"
      style={debugStyle}
    >
      <label className="flex items-center">
        <Input.CheckBox value={many} onChange={setMany} />
        多数データでデバッグ
      </label>
    </AfterLoaded>
  )
}

const AfterLoaded = ({ rowData, rowTypeData, className, style, children }: {
  rowData: RowObject[]
  rowTypeData: RowType[]
  className?: string
  style?: React.CSSProperties
  children?: React.ReactNode
}) => {

  const gridRef = useRef<Collection.DataTableRef<GridRow>>(null)

  // RowType
  const [{ rowTypeMap }, dispatchRowType] = useReducer(rowTypeMapReducer, undefined, () => ({ rowTypeMap: new Map() }))
  useEffect(() => {
    dispatchRowType(state => state.init(rowTypeData))
  }, [rowTypeData])

  // 行
  const { control, reset } = Util.useFormEx<PageFormState>({})
  const { fields, insert, update, remove } = useFieldArray({ control, name: 'gridRows' })
  useEffect(() => {
    reset({ gridRows: toGridRows(rowData) })
  }, [rowData])

  // 列
  const [columnCount, setColumnCount] = useState(4)
  const [indentSize, setIndentSize] = useState(24)
  const columnDefs = useMemo((): Collection.ColumnDefEx<Util.TreeNode<GridRow>>[] => [
    // ラベルの列
    {
      id: 'col0',
      header: '　',
      size: 640,
      cell: cellProps => {
        const bgColor = cellProps.row.original.item.type === 'rowType' ? ROWTYPE_STYLE : ''
        const style: React.CSSProperties = { marginLeft: cellProps.row.original.item.indent * indentSize }
        return (
          <span className={`block w-full px-1 overflow-hidden whitespace-nowrap ${bgColor}`} style={style}>
            {getLabelCellValue(cellProps.row.original.item, rowTypeMap)}&nbsp;
          </span>
        )
      },
      accessorFn: data => getLabelCellValue(data.item, rowTypeMap),
      setValue: (row, value) => {
        const { updatedRowType } = setLabelCellValue(row.item, rowTypeMap, value)
        if (updatedRowType) dispatchRowType(state => state.set({ ...updatedRowType }))
      },
      cellEditor: (props, ref) => <Input.Word ref={ref} {...props} />,

    },

    // 属性の列
    ...Array.from({ length: columnCount }, (_, i) => i).map<Collection.ColumnDefEx<Util.TreeNode<GridRow>>>(i => ({
      id: `col${i + 1}`,
      header: '　',
      cell: cellProps => {
        const bgColor = cellProps.row.original.item.type === 'rowType' ? ROWTYPE_STYLE : ''
        return (
          <span className={`block w-full px-1 overflow-hidden whitespace-nowrap ${bgColor}`}>
            {getAttrCellValue(cellProps.row.original.item, rowTypeMap, i)}&nbsp;
          </span>
        )
      },
      accessorFn: data => getAttrCellValue(data.item, rowTypeMap, i),
      setValue: (row, value) => {
        const { updatedRowType } = setAttrCellValue(row.item, rowTypeMap, i, value)
        if (updatedRowType) dispatchRowType(state => state.set({ ...updatedRowType }))
      },
      cellEditor: (props, ref) => <Input.Word ref={ref} {...props} />,
    }))
  ], [columnCount, indentSize, rowTypeMap, update, dispatchRowType])

  // -------------------------------------
  // イベント
  const handleAddRow = useCallback(() => {
    const selectedRows = gridRef.current?.getSelectedRows()
    if (!selectedRows || selectedRows.length === 0) return
    const insertPoint = selectedRows[0]
    insert(insertPoint.rowIndex, insertNewRow(insertPoint.row))
  }, [insert])

  const handleDeleteRows = useCallback(() => {
    const selectedRowIndexes = gridRef.current
      ?.getSelectedRows()
      .map(({ rowIndex }) => rowIndex)
    if (!selectedRowIndexes) return
    remove(selectedRowIndexes)
  }, [remove])

  const onKeyDown: Collection.DataTableKeyDownEvent<GridRow> = useCallback((e, { row, rowIndex }) => {
    // TABキーによるインデントの上げ下げ
    if (e.key === 'Tab') {
      row.item.indent = e.shiftKey
        ? Math.max(0, row.item.indent - 1)
        : (row.item.indent + 1)
      update(rowIndex, row.item)
      e.preventDefault()
    }
    // Ctrl + Enter による行追加
    else if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      handleAddRow()
      e.preventDefault()
    }
    // Shift + Delete による行削除
    else if (e.shiftKey && e.key === 'Delete') {
      handleDeleteRows()
      e.preventDefault()
    }
  }, [update, handleAddRow, handleDeleteRows])

  return (
    <div className={`flex flex-col gap-1 ${className ?? ''}`} style={style}>
      <div className="flex gap-1 items-center">
        <Input.IconButton icon={PlusIcon} onClick={handleAddRow} hideText className="p-1">追加（Ctrl + Enter）</Input.IconButton>
        <Input.IconButton icon={TrashIcon} onClick={handleDeleteRows} hideText className="p-1">削除（Shift + Delete）</Input.IconButton>
        <div className="flex-1"></div>
        {children}
      </div>
      <Collection.DataTable
        ref={gridRef}
        data={fields}
        columns={columnDefs}
        onChangeRow={update}
        onKeyDown={onKeyDown}
        className="flex-1 h-full"
      />
    </div>
  )
}

const ROWTYPE_STYLE = 'text-neutral-500 bg-neutral-500/10'

type PageFormState = {
  gridRows: GridRow[]
}

const rowTypeMapReducer = Util.defineReducer((state: {
  rowTypeMap: Map<RowTypeId, RowType>
}) => ({
  init: (rowTypes: RowType[]) => ({
    rowTypeMap: new Map(rowTypes.map(t => [t.id, t])),
  }),
  set: (rowType: RowType) => {
    const rowTypeMap = new Map(state.rowTypeMap)
    rowTypeMap.set(rowType.id, rowType)
    return { rowTypeMap }
  },
}))
